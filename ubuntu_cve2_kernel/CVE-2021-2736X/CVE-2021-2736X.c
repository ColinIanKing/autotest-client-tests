/* SPDX-License-Identifier: GPL-2.0-or-later */
/* Author: Thadeu Lima de Souza Cascardo <cascardo@canonical.com> */
#include <sys/socket.h>
#include <unistd.h>
#include <linux/netlink.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <stdio.h>
#include <err.h>
#include "iscsi_if.h"

static void load_module(void)
{
	system("modprobe iscsi_tcp");
}

static uint64_t get_handle(void)
{
	int fd;
	char buf[32];
	int r;

	errno = 0;
	fd = open("/sys/class/iscsi_transport/tcp/handle", O_RDONLY);
	if (fd < 0) {
		if (errno != EPERM && errno != EACCES)
			err(1, "failed to open handle file");
		return -1;
	}

	errno = 0;
	r = read(fd, buf, sizeof(buf));
	if (r < 0) {
		if (errno != EPERM && errno != EACCES)
			err(1, "failed to open handle file");
		return -1;
	}
	close(fd);
	return strtoull(buf, NULL, 0);
}


static int netlink_iscsi_socket(void)
{
	int cs;
	struct sockaddr_nl snl;
	int r;

	snl.nl_family = AF_NETLINK;
	snl.nl_pid = 0;
	snl.nl_groups = ISCSI_NL_GRP_ISCSID;

	cs = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ISCSI);
	if (cs < 0)
		err(1, "Failed to create netlink_iscsi socket");

	r = bind(cs, (struct sockaddr *) &snl, sizeof(snl));
	/* This will fail when we are doing create_session as non-root */
	if (r < 0 && geteuid() == 0)
		warn("Failed to bind to iscsid group");

	return cs;
}

static int create_session(uint64_t handle, uint32_t *sid, uint32_t *host_no)
{
	struct nlmsghdr *hdr;
	struct iscsi_uevent *ev;
	char buf[sizeof(*hdr) + sizeof(*ev)];
	int cs = netlink_iscsi_socket();

	int r;
	int retries = 0;

	hdr = (void *) buf;
	ev = (void *) (hdr + 1);

	hdr->nlmsg_pid = 0;
	hdr->nlmsg_seq = 1;
	hdr->nlmsg_flags = NLM_F_ACK;
	hdr->nlmsg_len = sizeof(*hdr) + sizeof(*ev);
	hdr->nlmsg_type = ISCSI_UEVENT_CREATE_SESSION;

	ev->transport_handle = handle;
	ev->u.c_session.initial_cmdsn = 1;
	ev->u.c_session.cmds_max = 16;
	ev->u.c_session.queue_depth = 1;
	ev->iferror = 0;

	send(cs, hdr, hdr->nlmsg_len, 0);
retry:
	errno = 0;
	r = recv(cs, buf, sizeof(buf), MSG_DONTWAIT);
	if (r != (sizeof(*hdr) + sizeof(*ev))) {
		if (errno == EAGAIN) {
			if (retries++ < 3)
				goto retry;
			fprintf(stderr, "possibly missing commit af17092810a887178195276255b7b31f8fbe7dbe\n");
			fprintf(stderr, "cannot check creation result\n");
			close(cs);
			return EAGAIN;
		} else {
			ev->iferror = -errno;
		}
	} else if (hdr->nlmsg_type != ISCSI_UEVENT_CREATE_SESSION) {
		/* Possible notification of session creation */
		if (ev->type != ISCSI_KEVENT_CREATE_SESSION)
			fprintf(stderr, "got an unexpected message with types 0x%x 0x%x, retrying\n", hdr->nlmsg_type, ev->type);
		goto retry;
	}
	close(cs);

	if (ev->iferror != 0)
		return -ev->iferror;

	*sid = ev->r.c_session_ret.sid;
	*host_no = ev->r.c_session_ret.host_no;

	return 0;
}

static int set_initiator_name(uint64_t handle, uint32_t host_no)
{
	struct nlmsghdr *hdr;
	struct iscsi_uevent *ev;
	char *buf;
	int cs = netlink_iscsi_socket();
	int r;
	int page_size = sysconf(_SC_PAGESIZE);
	buf = malloc(sizeof(*hdr) + sizeof(*ev) + 2 * page_size);

	hdr = (void *) buf;
	ev = (void *) (hdr + 1);
	memset(buf + sizeof(*hdr) + sizeof(*ev), 'A', 2 * page_size);

	hdr->nlmsg_pid = 0;
	hdr->nlmsg_seq = 1;
	hdr->nlmsg_flags = NLM_F_ACK;
	hdr->nlmsg_len = sizeof(*hdr) + sizeof(*ev) + 2 * page_size;
	hdr->nlmsg_type = ISCSI_UEVENT_SET_HOST_PARAM;

	ev->transport_handle = handle;
	ev->u.set_host_param.host_no = host_no;
	ev->u.set_host_param.len = 2 * page_size;
	ev->u.set_host_param.param = ISCSI_HOST_PARAM_INITIATOR_NAME;
	ev->iferror = 0;
	send(cs, hdr, hdr->nlmsg_len, 0);
	r = recv(cs, buf, sizeof(*hdr) + sizeof(*ev), MSG_DONTWAIT);
	if (r != (sizeof(*hdr) + sizeof(*ev))) {
		ev->iferror = -errno;
	}
	close(cs);

	free(buf);
	return -ev->iferror;
}

static int destroy_session(uint64_t handle, uint32_t sid)
{
	struct nlmsghdr *hdr;
	struct iscsi_uevent *ev;
	char buf[sizeof(*hdr) + sizeof(*ev)];
	int cs = netlink_iscsi_socket();
	int r;

	hdr = (void *) buf;
	ev = (void *) (hdr + 1);

	hdr->nlmsg_pid = 0;
	hdr->nlmsg_seq = 1;
	hdr->nlmsg_flags = NLM_F_ACK;
	hdr->nlmsg_len = sizeof(*hdr) + sizeof(*ev);
	hdr->nlmsg_type = ISCSI_UEVENT_DESTROY_SESSION;

	ev->transport_handle = handle;
	ev->u.d_session.sid = sid;
	ev->iferror = 0;

	send(cs, hdr, hdr->nlmsg_len, 0);
	r = recv(cs, buf, sizeof(buf), MSG_DONTWAIT);
	if (r != (sizeof(*hdr) + sizeof(*ev))) {
		ev->iferror = -errno;
	}
	close(cs);

	return -ev->iferror;
}

int main(int argc, char **argv)
{

	int errors = 0;
	int passes = 0;
	int unknown = 0;

	uint64_t handle;
	uint32_t sid;
	uint32_t host_no;

	int r;

	load_module();

	setreuid(-1, 1000);
	handle = get_handle();
	if (handle == (uint64_t) -1 && (errno == EPERM || errno == EACCES)) {
		passes++;
		printf("PASS: cannot read handle\n");
	} else {
		errors++;
		fprintf(stderr, "FAIL: was able to read handle\n");
	}
	setreuid(-1, 0);

	handle = get_handle();
	if (handle == (uint64_t) -1)
		err(1, "failed to read handle");

	setreuid(-1, 1000);
	r = create_session(handle, &sid, &host_no);
	if (r == EPERM || r == EACCES) {
		passes++;
		printf("PASS: cannot create session\n");
	} else if (r == EAGAIN) {
		/*
		 * FIXME: We could try and read from a root socket for notifications.
		 */
		unknown++;
		fprintf(stderr, "UNKNOWN: cannot create session with EAGAIN\n");
	} else {
		errors++;
		fprintf(stderr, "FAIL: was able to create session\n");
	}
	setreuid(-1, 0);

	r = create_session(handle, &sid, &host_no);
	if (r != 0) {
		errno = r;
		err(1, "failed to create session");
	}

	r = set_initiator_name(handle, host_no);
	if (r == 0) {
		errors++;
		fprintf(stderr, "FAIL: was able to set large initiator name\n");
	} else {
		passes++;
		printf("PASS: failed to set large initiator name: %d\n", r);
	}

	destroy_session(handle, sid);

	printf("PASS/UNKNOWN/TOTAL: %d/%d/%d\n", passes, unknown, unknown + passes + errors);

	if (errors)
		return 1;

	return 0;
}
